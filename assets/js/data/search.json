[ { "title": "WinDbg Preview - a dirty fix for \"Levels not implemented for this platform\"", "url": "/posts/WinDbg-levels-not-implemented-for-this-platform/", "categories": "WINDBG, ASSEMBLY", "tags": "windows, windbg, x86-64", "date": "2023-02-19 00:00:00 -0500", "snippet": "The issueImagine being deep into a kernel debugging session and suddenly your debugger stops working as expected.(This has beengoing on foryears at this point and it doesn’t look like there’s active interest in fixing or investigating the bug, yet.)Still, it continues to be a crippling bug that affects us at the worst possible times.Rebooting to roll the dice in hopes this will temporarily fix the issue might be out of the question since debugging without symbols is already quite involved, and scrapping progress in for convenience’s sake feels like a massive waste of time, so let’s try to figure out what causes this to happen by looking at the symptoms.KdExts.dllExtensions! !pte is what’s called an extension in WinDbg terms, that is, it’s not core functionality since it only applies to kernel debugging sessions.It is therefore implemented in the Kernel Debugger Extensions DLL (KdExts.dll) found in the install directory of WinDbg - which is likely somewhere in C:\\Program Files\\WindowsApps, for my particular version it is found atC:\\Program Files\\WindowsApps\\Microsoft.WinDbg_1.2210.3001.0_x64__8wekyb3d8bbwe\\amd64\\winxp\\kdexts.dllI’ll save you the trouble of finding where exactly the “Levels not implemented for this platform” message is referenced (you can do this an exercise if you’d like), and show you what the code responsible looks like once decompliled: ... switch ( g_TargetMachine ) // debuggee machine's arch { case IMAGE_FILE_MACHINE_I386: goto I386; case IMAGE_FILE_MACHINE_ARM: case IMAGE_FILE_MACHINE_THUMB: case IMAGE_FILE_MACHINE_ARMNT: v10 = 10; I386: v9 = 2; if ( !PaeEnabled ) v10 = 10; break; case IMAGE_FILE_MACHINE_AMD64: // we're obviously debugging an x64 machine v9 = DbgPagingLevels; if ( (unsigned int)DbgPagingLevels &gt; 5 ) // Paging levels above 5 aren't implemented yet { msg = \"Levels not implemented for this platform\\n\"; goto FAIL; } break; ... FAIL: ExtensionApis.lpOutputRoutine(msg); return -1; } ...If you’re not familiar with paging, this odsev article has some insight into why our bug is so absurd.WinDbg-InceptionHere comes the dirty fix part.We have : symbols for kdexts.dll; a debugger (yes, we’ll use WinDbg to patch WinDbg); a good sense of humorThe fixSteps: open a second instance of WinDbg and attach to the faulty instance; issue the .reload /f command to force symbol loading; locate the g_TargetMachine global variable and confirm it’s still IMAGE_FILE_MACHINE_AMD64 (0x8664) great, let’s look at DbgPagingLevelsThat makes no sense.Let’s edit the memory to reflect the correct value (which as of Feb 2023 should be either 4 or 5 depending on your CPU/Windows Edition combo).I’ll edit it to 4, because of my CPU is quite an old one and I’m not using Windows Server edition. (This is bound to be way more variable in the future, but by then, hopefully you won’t need this guide anymore). hit g or Go button and make sure your Kd debugger instance is stable detach from from it and close the second WinDbg instance now try !pte againAnd that’s it, you can keep on hunting bugs.I hope this was useful.Note:This is not a proper fix, and this article skips the root cause analysis of this behavior.It is intended to be a quick way of dealing with the issue when it presents itself.Additional analysis may or may not be posted here as an update, but for now I’m only interested in continuing the work I was interrupted from." }, { "title": "Writing A (covert) Dynamic Loader in x86-64 MASM [0x02]", "url": "/posts/Dynamic-Loader-x86-64-MASM-0x02/", "categories": "PROGRAMMING, ASSEMBLY", "tags": "windows, masm, x86-64", "date": "2022-07-01 00:00:00 -0400", "snippet": " [0x02] - The ProblemImports:As the analysts we’d like to quickly get an idea of what this binary is doing statically.So we sit down, open our favorite tool and check what kind of file it is, what libraries it depends on and what functions it calls:Imports tab in IDALooks like this executable will perform dynamic linking at runtime, which is generally a red flag when dealing with unknown programs - even more so when it’s the only functionality that’s exposed to us.Strings:Another major giveaway are strings because they shine a light on the intentions of a programmer.Here we can see that the author didn’t bother concealing their intentions, giving us valuable insight into what is going on:Strings tab in IDA (Shift + F12)by simply looking at this we can be confident that the binary will: get a handle to kerne32.dll; load user32.dll since it wasn’t linked at compile time; resolve LoadLibraryA, ExitProcess, Beep and MessageBoxA.and we didn’t need to look at a single byte of code.The code:Not satisfied with just strings and imports we decide to look at the code to make sure our assumptions are correct.The entry point looks very minimal as there’s only 3 function calls.Once decompiled, the first function looks like so:(Hit “\\” to get rid of type casts)Nothing that we didn’t know already, so what about the second function?Not much going on here either and that little that’s going on is clear as day.The last function call is a little different as it appears to be a dynamically resolved API, which we’ve seen in function 1 as ExitProcess.ConclusionThe author of this program has been careless enough to let us know all their secrets and we have a good understanding of what their code does.Maybe nex time we won’t be as lucky, but for now we publish our research and call it a win.Score: sloppy at best." }, { "title": "Writing A (covert) Dynamic Loader in x86-64 MASM [0x01]", "url": "/posts/Dynamic-Loader-x86-64-MASM-0x01/", "categories": "PROGRAMMING, ASSEMBLY", "tags": "windows, masm, x86-64", "date": "2022-06-28 00:00:00 -0400", "snippet": " [0x01] - General Code StructureWhat we’re doing: How we’re doing it:We’ll start by declaring the only two imports we require to bootstrap our loader.; HMODULE GetModuleHandleA(LPCSTR modulename)EXTRN __imp_GetModuleHandleA:PROC; FARPROC GetProcAddress (HMODULE modulehandle, LPCSTR procname)EXTRN __imp_GetProcAddress:PROCThe next step is to prepare some static global variables in the .data section.; Static data _DATA SEGMENT User32dll db \"User32.dll\", 0h Kernel32dll db \"kernel32.dll\", 0h Beep db \"Beep\", 0h LoadLibraryA db \"LoadLibraryA\", 0h MessageBoxA db \"MessageBoxA\", 0h ExitProcess db \"ExitProcess\", 0h Caption db \"Hello!\", 0h Message db \"Click on \", '\"', \"Ok\", '\"', '.', 0h_DATA ENDSWe’ll also need global variables for the resolved APIs (function pointers), zero initialized.; Uninitialized data_BSS SEGMENT align(8) READ WRITE User32Ptr dq 0000000000000000h Kernel32Ptr dq 0000000000000000h BeepPtr dq 0000000000000000h MessageBoxAPtr dq 0000000000000000h ExitProcessPtr dq 0000000000000000h LoadLibraryAPtr dq 0000000000000000h_BSS ENDSOur code will live in the .text section and contains 3 functions: start, setup and main.start is the entry point and is responsible for the loader’s general code flow: it calls setup, then main and terminates the process.; Code_TEXT SEGMENT ; Entry point start PROC sub rsp, 8 call setup call main mov rcx, rax call ExitProcessPtr add rsp, 8 ret start ENDPsetup is responsible for resolving APIs and saving the resulting function pointers in the .bss section using GetModuleHandleA, LoadLibraryA and GetProcAddress. ; Resolves Win32 APIs and saves function ptrs as ; global variables for later use setup PROC sub rsp, 28h lea rcx, Kernel32dll call QWORD PTR __imp_GetModuleHandleA ; Kernel32Ptr = GetModuleHandleA (\"kernel32.dll\") mov Kernel32Ptr, rax mov rcx, Kernel32Ptr lea rdx, LoadLibraryA call QWORD PTR __imp_GetProcAddress ; LoadLibraryAPtr = GetProcAddress (Kernel32Ptr, \"LoadLibraryA\") mov LoadLibraryAPtr, rax lea rcx, User32dll call LoadLibraryAPtr ; User32Ptr = LoadLibraryA (\"user32.dll\") mov User32Ptr, rax mov rcx, Kernel32Ptr lea rdx, Beep call QWORD PTR __imp_GetProcAddress ; BeepPtr = GetProcAddress (Kernel32Ptr, \"Beep\") mov BeepPtr, rax mov rcx, User32Ptr lea rdx, MessageBoxA call QWORD PTR __imp_GetProcAddress ; MessageBoxAPtr = GetProcAddress (User32Ptr, \"MessageBoxA\") mov MessageBoxAPtr, rax mov rcx, Kernel32Ptr lea rdx, ExitProcess call QWORD PTR __imp_GetProcAddress ; ExitProcessPtr = GetProcAddress (Kernel32Ptr, \"ExitProcess\") mov ExitProcessPtr, rax add rsp, 28h ret setup ENDPFinally, we call main which is where the program starts using the collected artifacts: ; Just like nothing happened! main PROC sub rsp, 28h xor ecx, ecx lea rdx, Message lea r8, Caption xor r9d, r9d call MessageBoxAPtr ; MessageBoxA (NULL, Message, Caption, NULL) mov ecx, 100h mov edx, 100h call BeepPtr ; Beep (256, 256) add rsp, 28h ret main ENDP_TEXT ENDSENDAssemble and Link:Paste the following code in a file called make.bat:@echo offif [\"%~1\"]==[\"\"] (\t ml64 main.asm /link /entry:start /subsystem:windows /OUT:poc.exe kernel32.lib /nologo) else if [\"%~1\"]==[\"clean\"] (\t del *.obj,*.exe,*.lnk) else (\techo usage:\techo make - assembles and links main.asm into poc.exe.\techo make clean - deletes all .exe, .obj and .lnk files in the dir.)@echo onThis will serve as a rudimentary build system, and that’s all we really need in this case.Issue the make command.If your copy pasta game is on point you should see our poc.exe binary.And that’s it!We now have a functional piece of code that we can use as reference." }, { "title": "Writing A (covert) Dynamic Loader in x86-64 MASM [0x00]", "url": "/posts/Dynamic-Loader-x86-64-MASM-0x00/", "categories": "PROGRAMMING, ASSEMBLY", "tags": "windows, masm, x86-64", "date": "2022-06-28 00:00:00 -0400", "snippet": " [0x00] - Introduction Assumptions about the reader’s knowledge: Understanding of C code (pointers, structs, control flow …); Some Python3 experience (basic operations); Some Assembly experience (g.p. registers, stack layout, control flow …); Basic computer usage knowledge.Goals of this series: Get a working POC that when inspected statically gives nothing away; Avoid AV flagging; Get more comfortable in writing x86-64 Assembly code; Call Kernel32!Beep without importing it directly; Having fun, otherwise what’s the point?Tools used in this series: Operating System: Windows 11; Code Editor: Visual Studio Code; VS Code extension: x86-64 ASM Syntax Highlighting; Assembler: MASM; Scripting/Automation: Python3; Debugger: WinDbg; Disassembler/Decompiler: IDA Freeware; and of course: Just a little Patience.Inspiration, techniques and external resources: Architecture 1001: x86-64 Assembly by (@XenoKovah); Undocumented Windows Structs (by RevJay and SergiusTheBest); PEB Walking (by @christophetd); API Hashing (by @spotheplanet); Malware Development (by 0xPat)." } ]
